"""
This module gives the interacting edge calculation with a possible potential V(X)
and the densities of the two ends may be fixed.
"""
#module LLHFEDGE
    

using MKL
using LinearAlgebra
using TensorOperations
using QuadGK
using PhysicalUnits
using MoireIVC.LLHF
using MoireIVC.Basics: ql_cross
using MoireIVC.LLHF: LLHFNumPara, LLHFSysPara, Form_factor

N1=2
CartesianIndices((N1,N1,N1,N1))
for i in CartesianIndices((N1,N1,N1,N1))
    println(i)
end

# Hartree[Z, Z′, X, X′, τZ, τX, py, ky]
function Hartree!(
    Hartree::Array{ComplexF64,8}, 
    N1::Int64, N2::Int64, LL::Int64, system::LLHFSysPara;
    maxLxShift::Int64 = 2,
)
    Hartree .= 0.0

    for Idx in CartesianIndices(Hartree)
        Z  = Idx[1] -1
        Z′ = Idx[2] -1
        X  = Idx[3] -1
        X′ = Idx[4] -1
        τZ = 3-2Idx[5]
        τX = 3-2Idx[6]
        py = Idx[7] -1
        ky = Idx[8] -1
        if ( τZ*(Z′-Z) - τX*(X-X′) ) % N1 == 0
            p_ZX = ( τZ*(Z′-Z) - τX*(X-X′) ) ÷ N1
            qy = system.G2[2] * τX * (X-X′)

            for LxShift in -maxLxShift:maxLxShift

                qqy = qy + LxShift * system.G2[2] * τX * N1

                function VFF(qx)

                end

                integral = quadgk(VFF, -∞, ∞)[1]

                Hartree[Idx] += integral * cis()
            end

        end
    end
    return Hartree
end



    for Gy in -maxLxShift:maxLxShift
        

            V = V_int(Gx*N1, Gy*N2; N1=N1, N2=N2, r12 = system.ratio12,
                Gl=system.Gl, D_l=system.D/system.l, cosθ=system.cosθ
            )

            for τp = (1,-1), τk = (1,-1)
                phase = [cis(ql_cross((τk*k1 - τp*p1)/N1, (τk*k2 - τp*p2)/N2, Gx, Gy) )
                    for p1 in 0:N1-1, p2 in 0:N2-1, k1 in 0:N1-1, k2 in 0:N2-1
                ]
                VFF = Form_factor(LL,LL, (-Gx*system.G1-Gy*system.G2)..., τk, system.l) * 
                    Form_factor(LL,LL, (Gx*system.G1+Gy*system.G2)..., τp, system.l) * V
                Hartree[:,:,:,:, (3-τp)÷2, (3-τk)÷2] .+= VFF .* phase 
            end
        end
    end

    return Hartree
end




@kwdef mutable struct LLEDPara

    system::LLHFSysPara

    LL::Int64 = 0    # Landau level index
    N1::Int64 = 1    # number of x
    N2::Int64 = 1    # number of ky 
    k_num::Int64 = N1*N2

    # H[X, τ, X′, τ′, ky]
    H0::Array{ComplexF64,5} = zeros(ComplexF64, N1, 2, N1, 2, N2)

    # Hartree[Z, Z′, X, X′, τZ, τX, py, ky]
    BareHartree::Array{ComplexF64,8} = Hartree!(
        zeros(ComplexF64, N1, N1, N1, N1, 2, 2, N2, N2), 
        N1, N2, LL, system,
    )
    # Fock[Z, Z′, X, X′, τ′, τ, py, ky]
    BareFock::Array{ComplexF64,8} = Fock!(
        zeros(ComplexF64, N1, N1, N1, N1, 2, 2, N2, N2), 
        N1, N2, LL, system,
    )
    Hartree::Array{ComplexF64,8} = BareHartree
    Fock::Array{ComplexF64,8} = BareFock

    # α : scale the intervalley interaction 
    # λ : scale down diagonal interaction(HA-HE-XA) 
    α::Float64 = 1.0
    λ::Float64 = 1.0

    # ρ[X, τ, X′, τ′, ky] = <c†_{X′,τn′,ky}c_{X,τn,ky}>
    DMseed::Array{ComplexF64,5} = fill(ComplexF64(0.5), N1, 2, N1, 2, N2)

end





"Hartree-Fock interacting mean field generated by density matrix"
function hf_interaction(ρ, para::LLHFNumPara)
    H = zeros(ComplexF64, size(para.H0))
    for τk in 1:2, τp in 1:2
        @tensor H[:,:, τk, τk][k1, k2] += 
        ρ[:,:, τp, τp][p1, p2] * para.Hartree[:,:,:,:,τp,τk][p1, p2, k1, k2]
    end
    for τn in 1:2, τn′ in 1:2
        @tensor H[:,:, τn′, τn][k1, k2] -= 
        ρ[:,:, τn′, τn][p1, p2] * para.Fock[:,:,:,:,τn′,τn][p1, p2, k1, k2]
    end
    return para.system.W0 / para.k_num * H
end




#end



